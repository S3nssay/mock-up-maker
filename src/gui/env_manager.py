import os
import shutil
from pathlib import Path
from typing import Dict, Optional, List
import re


class EnvManager:
    """Manage .env file operations for settings storage"""

    def __init__(self, env_file_path: Optional[str] = None):
        """Initialize env manager"""
        self.env_file = Path(env_file_path) if env_file_path else Path(".env")
        self.template_file = Path(".env.template")

    def load_env_vars(self) -> Dict[str, str]:
        """Load environment variables from .env file"""
        env_vars = {}

        # Load from actual environment first
        env_vars.update(dict(os.environ))

        # Load from .env file if it exists
        if self.env_file.exists():
            try:
                with open(self.env_file, 'r', encoding='utf-8') as f:
                    for line_num, line in enumerate(f, 1):
                        line = line.strip()

                        # Skip empty lines and comments
                        if not line or line.startswith('#'):
                            continue

                        # Parse KEY=VALUE format
                        if '=' in line:
                            key, value = line.split('=', 1)
                            key = key.strip()
                            value = value.strip()

                            # Remove quotes if present
                            if value.startswith('"') and value.endswith('"'):
                                value = value[1:-1]
                            elif value.startswith("'") and value.endswith("'"):
                                value = value[1:-1]

                            env_vars[key] = value

            except Exception as e:
                print(f"Warning: Error reading .env file: {e}")

        return env_vars

    def save_env_vars(self, settings_dict: Dict[str, str]) -> bool:
        """Save environment variables to .env file"""
        try:
            # Create backup if .env exists
            if self.env_file.exists():
                backup_path = Path(f"{self.env_file}.backup")
                shutil.copy2(self.env_file, backup_path)

            # Load existing content to preserve comments and structure
            existing_content = []
            existing_vars = set()

            if self.env_file.exists():
                with open(self.env_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        line_stripped = line.strip()
                        if line_stripped and not line_stripped.startswith('#') and '=' in line_stripped:
                            # Extract variable name
                            var_name = line_stripped.split('=', 1)[0].strip()
                            existing_vars.add(var_name)
                        existing_content.append(line.rstrip())

            # Write new .env file
            with open(self.env_file, 'w', encoding='utf-8') as f:
                # Write header comment
                f.write("# Excel Seedream Generator Configuration\n")
                f.write("# Generated by Settings GUI\n")
                f.write(f"# Last updated: {self._get_timestamp()}\n\n")

                # Write API keys section
                f.write("# API Provider Settings\n")
                api_keys = {
                    "AI_IMAGE_PROVIDER": "Primary AI image provider",
                    "SEEDREAM_KIE_API_KEY": "Seedream via Kie.ai API key",
                    "SEEDREAM_AIML_API_KEY": "Seedream via AI/ML API key",
                    "SEEDREAM_BYTEPLUS_API_KEY": "Seedream via BytePlus API key",
                    "NANO_BANANA_API_KEY": "Nano Banana API key",
                    "NANO_BANANA_ENDPOINT": "Nano Banana API endpoint"
                }

                for key, description in api_keys.items():
                    value = settings_dict.get(key, "")
                    if key == "NANO_BANANA_ENDPOINT" and not value:
                        value = "https://api.nano-banana.com/v1"  # Default endpoint
                    f.write(f"# {description}\n")
                    f.write(f"{key}={value}\n\n")

                # Write generation settings
                f.write("# Generation Settings\n")
                gen_settings = {
                    "DEFAULT_IMAGE_SIZE": "Default image aspect ratio",
                    "DEFAULT_RESOLUTION": "Default image resolution",
                    "CONCURRENT_REQUESTS": "Number of concurrent API requests",
                    "GUIDANCE_SCALE": "AI guidance scale for generation",
                    "NUM_INFERENCE_STEPS": "Number of inference steps"
                }

                for key, description in gen_settings.items():
                    value = settings_dict.get(key, "")
                    f.write(f"# {description}\n")
                    f.write(f"{key}={value}\n\n")

                # Write fallback settings
                f.write("# Provider Fallback\n")
                fallback_settings = {
                    "ENABLE_FALLBACK": "Enable automatic provider fallback",
                    "FALLBACK_ORDER": "Provider fallback order (comma-separated)"
                }

                for key, description in fallback_settings.items():
                    value = settings_dict.get(key, "")
                    if key == "FALLBACK_ORDER" and not value:
                        value = "seedream_kie,nano_banana,seedream_aiml"  # Default fallback order
                    f.write(f"# {description}\n")
                    f.write(f"{key}={value}\n\n")

                # Write output settings
                f.write("# Output Settings\n")
                output_settings = {
                    "OUTPUT_DIR": "Base output directory for generated images",
                    "IMAGE_FORMAT": "Output image format (PNG, JPEG, WEBP)",
                    "RESULTS_FILENAME": "Results Excel filename",
                    "ORGANIZE_BY_BRAND": "Organize output files by brand"
                }

                for key, description in output_settings.items():
                    value = settings_dict.get(key, "")
                    if key == "RESULTS_FILENAME" and not value:
                        value = "results.xlsx"
                    f.write(f"# {description}\n")
                    f.write(f"{key}={value}\n\n")

                # Write overlay settings
                f.write("# Overlay Settings\n")
                overlay_settings = {
                    "ENABLE_PRODUCT_OVERLAY": "Enable product information overlays",
                    "DEFAULT_OVERLAY_POSITION": "Default overlay position",
                    "OVERLAY_FONT_SIZE": "Default overlay font size",
                    "OVERLAY_BACKGROUND_OPACITY": "Overlay background opacity",
                    "QR_CODE_ENABLED": "Enable QR codes in overlays",
                    "QR_CODE_SIZE": "QR code size in pixels"
                }

                for key, description in overlay_settings.items():
                    value = settings_dict.get(key, "")
                    if key == "OVERLAY_FONT_SIZE" and not value:
                        value = "24"
                    f.write(f"# {description}\n")
                    f.write(f"{key}={value}\n\n")

                # Write cost control settings
                f.write("# Cost Control\n")
                cost_settings = {
                    "MAX_COST_PER_IMAGE": "Maximum cost per image in USD",
                    "TOTAL_BUDGET_LIMIT": "Total budget limit in USD"
                }

                for key, description in cost_settings.items():
                    value = settings_dict.get(key, "")
                    f.write(f"# {description}\n")
                    f.write(f"{key}={value}\n\n")

                # Write retry settings
                f.write("# Retry Settings\n")
                retry_settings = {
                    "MAX_RETRY_ATTEMPTS": "Maximum retry attempts for failed requests",
                    "RETRY_DELAY_SECONDS": "Delay between retry attempts in seconds"
                }

                for key, description in retry_settings.items():
                    value = settings_dict.get(key, "")
                    if key == "MAX_RETRY_ATTEMPTS" and not value:
                        value = "3"
                    elif key == "RETRY_DELAY_SECONDS" and not value:
                        value = "2"
                    f.write(f"# {description}\n")
                    f.write(f"{key}={value}\n\n")

            return True

        except Exception as e:
            print(f"Error saving .env file: {e}")
            return False

    def create_from_template(self) -> bool:
        """Create .env file from template"""
        try:
            if self.template_file.exists() and not self.env_file.exists():
                shutil.copy2(self.template_file, self.env_file)
                return True
            return False
        except Exception as e:
            print(f"Error creating .env from template: {e}")
            return False

    def validate_env_file(self) -> List[str]:
        """Validate .env file and return list of issues"""
        issues = []

        if not self.env_file.exists():
            issues.append("ERROR: .env file does not exist")
            return issues

        try:
            env_vars = self.load_env_vars()

            # Check for required variables
            required_vars = ["AI_IMAGE_PROVIDER"]
            for var in required_vars:
                if var not in env_vars or not env_vars[var]:
                    issues.append(f"WARNING: {var} is not set")

            # Check API keys
            api_keys = [
                "SEEDREAM_KIE_API_KEY",
                "SEEDREAM_AIML_API_KEY",
                "SEEDREAM_BYTEPLUS_API_KEY",
                "NANO_BANANA_API_KEY"
            ]

            available_keys = sum(1 for key in api_keys if env_vars.get(key))
            if available_keys == 0:
                issues.append("ERROR: No API keys configured")
            elif available_keys == 1:
                issues.append("WARNING: Only one API key configured. Consider adding backup providers.")

            # Validate numeric values
            numeric_vars = {
                "CONCURRENT_REQUESTS": (1, 10),
                "GUIDANCE_SCALE": (1.0, 20.0),
                "NUM_INFERENCE_STEPS": (10, 100),
                "MAX_COST_PER_IMAGE": (0.001, 1.0),
                "TOTAL_BUDGET_LIMIT": (1.0, 10000.0),
                "QR_CODE_SIZE": (50, 500),
                "OVERLAY_BACKGROUND_OPACITY": (0.0, 1.0)
            }

            for var, (min_val, max_val) in numeric_vars.items():
                if var in env_vars:
                    try:
                        value = float(env_vars[var])
                        if not (min_val <= value <= max_val):
                            issues.append(f"WARNING: {var} value {value} outside recommended range {min_val}-{max_val}")
                    except ValueError:
                        issues.append(f"ERROR: {var} has invalid numeric value: {env_vars[var]}")

            # Validate enum values
            enum_vars = {
                "AI_IMAGE_PROVIDER": ["seedream_kie", "nano_banana", "seedream_aiml", "seedream_byteplus"],
                "DEFAULT_RESOLUTION": ["HD", "FHD", "2K", "4K"],
                "DEFAULT_IMAGE_SIZE": ["landscape_4_3", "landscape_16_9", "portrait_3_4", "portrait_9_16", "square"],
                "IMAGE_FORMAT": ["PNG", "JPEG", "WEBP"],
                "DEFAULT_OVERLAY_POSITION": ["bottom-left", "bottom-right", "top-left", "top-right", "center-bottom", "center-top"]
            }

            for var, valid_values in enum_vars.items():
                if var in env_vars and env_vars[var] not in valid_values:
                    issues.append(f"WARNING: {var} has invalid value '{env_vars[var]}'. Valid options: {', '.join(valid_values)}")

        except Exception as e:
            issues.append(f"ERROR: Failed to validate .env file: {str(e)}")

        return issues

    def backup_env_file(self) -> Optional[str]:
        """Create backup of current .env file"""
        try:
            if self.env_file.exists():
                timestamp = self._get_timestamp().replace(":", "-").replace(" ", "_")
                backup_path = Path(f"{self.env_file}.backup.{timestamp}")
                shutil.copy2(self.env_file, backup_path)
                return str(backup_path)
        except Exception as e:
            print(f"Error creating backup: {e}")
        return None

    def restore_from_backup(self, backup_path: str) -> bool:
        """Restore .env file from backup"""
        try:
            backup_file = Path(backup_path)
            if backup_file.exists():
                shutil.copy2(backup_file, self.env_file)
                return True
        except Exception as e:
            print(f"Error restoring from backup: {e}")
        return False

    def get_backup_files(self) -> List[str]:
        """Get list of available backup files"""
        try:
            backup_pattern = f"{self.env_file.name}.backup*"
            backups = list(self.env_file.parent.glob(backup_pattern))
            return [str(backup) for backup in sorted(backups, reverse=True)]
        except Exception:
            return []

    def _get_timestamp(self) -> str:
        """Get current timestamp string"""
        from datetime import datetime
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def _sanitize_value(self, value: str) -> str:
        """Sanitize environment variable value"""
        # Remove potentially dangerous characters
        value = str(value).strip()

        # Quote value if it contains spaces or special characters
        if ' ' in value or any(char in value for char in ['$', '`', '"', "'"]):
            # Escape existing quotes
            value = value.replace('"', '\\"')
            value = f'"{value}"'

        return value